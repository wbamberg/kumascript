<%

const propertiesUrl = "https://raw.githubusercontent.com/mdn/data/master/css/properties.json";
const syntaxesUrl = "https://raw.githubusercontent.com/mdn/data/master/css/syntaxes.json";
const properties = mdn.fetchJSONResource(propertiesUrl);
const syntaxes = mdn.fetchJSONResource(syntaxesUrl);

const csstree = require('css-tree');

const excludeTheseTypes = [
  "named-color",
  "deprecated-system-color"
]

const legendItemDefinitions = {
  '&&': 'Components are mandatory but may appear in any order.',
  '||': 'At least one of the components must be present, and they may appear in any order.',
  '|': 'Exactly one of the components must be present.',
  '*': 'Zero or more times.',
  '+': 'One or more times.',
  '?': 'Zero or one time (that is, optional).',
  '{A,B}': 'At least A times, at most B times.',
  '#': 'One or more times, but each occurrence separated by a comma (\',\').',
  '!': 'Group must produce at least one value.'
}

function writeSyntax(type, syntax) {

  let ast = csstree.grammar.parse(syntax);
  let output = '';

  // get the CSS class for a term, for syntax highlighting
  function getClass(type) {
    switch (type) {
      case 'Type':
      case 'Property':
        return ' class=\'token property\'';
      case 'Keyword':
        return ' class=\'token keyword\'';
/*      case 'Slash':
        return ' class=\'css-formal-syntax-slash\'';
      case 'Group':
        return ' class=\'css-formal-syntax-group\'';
*/      case 'Function':
        return ' class=\'token function\'';
    }
    return '';
  }

  function buildLink(node, string, span) {
    if (syntaxes[node.name]) {
      return "<a href=\"#" + string + "\">" + span + "</a>";
    }
    return span;
  }

  function transform(string, node) {

    if (node.combinator) {
    }

    if (node.type == "Type") {
      // encode < and >
      string = string.replace('<', '&lt;');
      string = string.replace('>', '&gt;');
    }

    // add <span> markup with classes for syntax highlighting
    return buildLink(node, string, `<span${getClass(node.type)}>${string}</span>`);
  }

  function writeTerms(terms, combinator) {

    let output = '';
    let termArray = [];
    let termTextLengths = [];

    for (term of terms) {
      // figure out the lengths of the translated terms, without markup
      // this is just so we can align the terms properly
      let termTextLength = csstree.grammar.generate(term).length;
      termTextLengths.push(termTextLength);

      // get the translated terms, with markup
      let termText = csstree.grammar.generate(term, false, transform);
      termArray.push(termText);
    }

    let maxTermLength = Math.max(...termTextLengths);

    // write out the translated terms, padding with spaces for alignment
    // and separating terms using their combinator symbol
    for (let i = 0; i < termArray.length; i++) {
      let termText = termArray[i];
      let spaceCount = (maxTermLength + 2) - termTextLengths[i];
      let combinatorText = '';
      if (i < termArray.length-1) {
        combinatorText = `<span${getClass('Group')}>${combinator}</span>`;
      }
      output += '  ' + termText + Array(spaceCount).join(' ') + combinatorText + '<br/>';
    }

  return output;

  }

  let typeName = `&lt;${type}&gt;`;

  if ((ast.terms.length === 1) && (ast.terms[0].type == 'Function')) {
    // if the formal syntax just contains a function, write the function name
    // and write out its parameters
    output += `<span${getClass('Type')} id="${typeName}">${typeName} = </span>`;
    output += `<span${getClass('Function')}>${ast.terms[0].name} (</span><br/>`;
    output += writeTerms(ast.terms[0].children.terms, ast.terms[0].children.combinator);
    output += `<span${getClass('Function')}>)</span><br/>`;
  } else {
     if (ast.terms.length === 1) {
       output += `<span${getClass('Type')} id="${typeName}">${typeName} = </span><br/>`;
       output += writeTerms([ast], '');
     } else {
       // otherwise just write out the immediate contents
       output += `<span${getClass('Type')} id="${typeName}">${typeName} = </span><br/>`;
       output += writeTerms(ast.terms, ast.combinator);
     }
  }

  return output;
}

// given an item (such as a CSS property), fetch all the types that participate
// in its formal syntax definition, either directly or transitively
function getConstituentTypes(item) {

  // get names of all the types in a given set of syntaxes
  function getTypesForSyntaxes(syntaxes, constituents) {

    function processNode(node) {
      if (node.type == 'Type' &&
         (constituents.indexOf(node.name) === -1)) {
        constituents.push(node.name);
      }
    }

    for (syntax of syntaxes) {
      let ast = csstree.grammar.parse(syntax);
      csstree.grammar.walk(ast, processNode);
    }
  }

  let allConstituents = [];
  let oldConstituentsLength = allConstituents.length;
  // get all the types in the top-level syntax
  let constituentSyntaxes = [properties[item].syntax];
  getTypesForSyntaxes(constituentSyntaxes, allConstituents);

  // while an iteration added more types...
  while (allConstituents.length > oldConstituentsLength) {
    // get the syntaxes for all newly added constituents,
    // and then get the types in those syntaxes
    constituentSyntaxes = [];
    for (let constituent of allConstituents.slice(oldConstituentsLength)) {
      let constituentSyntaxEntry = syntaxes[constituent];
      if (constituentSyntaxEntry) {
        constituentSyntaxes.push(constituentSyntaxEntry.syntax);
      }
    }
    oldConstituentsLength = allConstituents.length;
    getTypesForSyntaxes(constituentSyntaxes, allConstituents);
  }

  return allConstituents;
}

function writeFormalSyntax(item) {

  let output = '';

  output += '<code>';

  output += writeSyntax(item, properties[item].syntax);
  output += '<br/>';

  let types = getConstituentTypes(item);
  for (type of types) {
    if (syntaxes[type] && (excludeTheseTypes.indexOf(type) === -1)) {
      output += writeSyntax(type, syntaxes[type].syntax);
      output += '<br/>';
    }
  }

  output += '</code>';

  return output;
}

let slug = env.slug;
let name = $0 || (slug ? slug.split("/").pop().toLowerCase() : "preview-wiki-content");

let output = writeFormalSyntax(name);
%>
<%-output%>
